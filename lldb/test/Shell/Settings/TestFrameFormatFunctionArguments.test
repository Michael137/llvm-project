# Test the ${function.arguments} frame-format variable.

# RUN: split-file %s %t
# RUN: %build %t/main.cpp -o %t.out
# RUN: %lldb -o "settings set interpreter.stop-command-source-on-error false" \
# RUN:       -x -b -s %t/commands.input %t.out -o exit 2>&1 \
# RUN:       | FileCheck %s
#
# Check that we have an appropriate fallback for languages that
# don't implement this frame format variable (in this case Objective-C).
#
# RUN: %build %t/main.m -o %t.objc.out
# RUN: %lldb -x -b -s %t/commands.input %t.objc.out -o exit 2>&1 \
# RUN:       | FileCheck %s --check-prefix=CHECK-OBJC

#--- main.cpp
struct Foo {
  void func() {}
};

void bar() {
  Foo{}.func();
}

void foo(int, int x) {
  bar();
}

void myFunc(char const * str,
          void (*fptr)(int, int)) {
  fptr(5, 10);
}

int main(int argc, char const *argv[]) {
    myFunc("hello", &foo);
    return 0;
}

#--- main.m

int func() {}
int bar() { func(); }

int main() { return bar(); }

#--- commands.input
settings set -f frame-format "custom-frame '${function.arguments}'\n"
break set -n func

run
bt

# CHECK: custom-frame '(this={{.*}})'
# CHECK: custom-frame '()'
# CHECK: custom-frame '((null)=5, x=10)'
# CHECK: custom-frame '(str="hello", fptr=({{.*}}.out`foo(int, int) at main.cpp:{{[0-9]+}}))'
# CHECK: custom-frame '(argc=1, argv={{.*}})'

# CHECK-OBJC: bt
# CHECK-OBJC-NOT: custom-frame
